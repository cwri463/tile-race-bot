from __future__ import annotations
"""
main.py – Discord Tile Race Bot (skip + reroll, with chat announcements)
=======================================================================
• Upload screenshot → ✅ / ❌ reaction for approval or decline
• !skip   – spend one *skip* token, ignore the current tile, roll ahead
• !reroll – step back one roll, then roll again from earlier tile
• Fork tiles: 🇦/🇧/… prompt when multiple paths are possible
• Board PNG regenerates after every move and on bot startup

The bot expects:
* env ‒vars:  DISCORD_TOKEN, IMAGE_CHANNEL_ID, NOTIFICATION_CHANNEL_ID, BOARD_CHANNEL_ID
* game ‒config.json generated by tools/csv_to_board.py  (must include tiles & teams)
"""

# --------------------------------------------------------------------------- #
# Imports & setup
# --------------------------------------------------------------------------- #
import os, asyncio, random, warnings
from typing import Dict, Any, List

import discord
import networkx as nx

from load_config import ETL
from utils.board import generate_board
from utils.game_functions import GameUtils

warnings.filterwarnings("ignore", category=UserWarning)

# --------------------------------------------------------------------------- #
# Emoji constants
# --------------------------------------------------------------------------- #
CHECK_EMOJI = "\N{WHITE HEAVY CHECK MARK}"   # ✅
CROSS_EMOJI = "\N{CROSS MARK}"               # ❌
FORK_EMOJIS = ["🇦", "🇧", "🇨", "🇩", "🇪", "🇫"]

# --------------------------------------------------------------------------- #
# Discord client
# --------------------------------------------------------------------------- #
intents = discord.Intents.default()
intents.message_content = True
intents.reactions = True
client = discord.Client(intents=intents)

# --------------------------------------------------------------------------- #
# Globals loaded at runtime
# --------------------------------------------------------------------------- #
image_channel_id: int
notification_channel_id: int
board_channel_id: int

board_data: Dict[str, Any]
tiles:      Dict[str, Dict[str, Any]]
teams:      Dict[str, Dict[str, Any]]
GRAPH:      nx.DiGraph

# --------------------------------------------------------------------------- #
# Utility helpers
# --------------------------------------------------------------------------- #
def is_me(msg: discord.Message) -> bool:
    return msg.author == client.user

def tile_index(tid: str) -> int:
    return int(tid.replace("tile", ""))

def tile_id(idx: int) -> str:
    return f"tile{idx}"

def announce(team: str, verb: str, old_tile: str, dice: int, new_tile: str):
    chan = client.get_channel(notification_channel_id)
    msg = (
        f"**{team}** {verb}: **{old_tile}** → **{new_tile}** "
        f"(🎲 {dice}) • rerolls **{teams[team]['rerolls']}** • "
        f"skips **{teams[team]['skips']}**"
    )
    asyncio.create_task(chan.send(msg))

async def refresh_board():
    chan = client.get_channel(board_channel_id)
    await chan.purge(check=is_me)
    generate_board(tiles, board_data, teams)
    await chan.send(file=discord.File("game_board.png"))
    print("[DEBUG] Board refreshed")

# --------------------------------------------------------------------------- #
# Movement logic
# --------------------------------------------------------------------------- #
async def choose_path(team: Dict[str, Any], paths: List[List[str]]):
    """
    Prompt a team to choose a fork.
    Duplicate destinations are collapsed so each tile appears only once.
    """
    # keep first path to each unique destination
    unique: Dict[str, List[str]] = {}
    for p in paths:
        dest = p[-1]
        if dest not in unique:
            unique[dest] = p

    channel = client.get_channel(notification_channel_id)
    prompt  = await channel.send(f"**{team['name']}**, choose your path:")

    emoji_map = {}
    for idx, (dest, path) in enumerate(unique.items()):
        if idx >= len(FORK_EMOJIS):   # safety: max 6 options
            break
        emoji = FORK_EMOJIS[idx]
        emoji_map[emoji] = dest
        await prompt.add_reaction(emoji)
        await channel.send(f"{emoji} → {tiles[dest]['item-name']}")

    team["pending_paths"] = emoji_map

async def advance_team(team: Dict[str, Any], dice: int):
    cur = team["tile"]
    paths: List[List[str]] = []

    for node in GRAPH.nodes:
        try:
            for p in nx.all_simple_paths(GRAPH, cur, node, cutoff=dice):
                if len(p) - 1 == dice:
                    paths.append(p)
        except nx.NetworkXNoPath:
            continue

    if not paths:
        print(f"[MOVE] No path from {cur} with roll {dice}")
        return

    if len(paths) == 1:
        team["tile"] = paths[0][-1]
        return

    await choose_path(team, paths)

async def perform_reroll(team_name: str):
    team = teams[team_name]
    if team["rerolls"] <= 0:
        await client.get_channel(notification_channel_id).send(
            f"Team **{team_name}** has no rerolls left.")
        return

    back_idx = tile_index(team["tile"]) - team.get("last_roll", 0)
    team["tile"] = tile_id(back_idx)

    dice = GameUtils.roll_dice(3, bonus_roll=True)
    old_tile_name = tiles[tile_id(back_idx)]["item-name"]

    await advance_team(team, dice)
    GameUtils.update_last_roll(team, dice)
    team["rerolls"] -= 1

    announce(team_name, "rerolled", old_tile_name, dice, tiles[team["tile"]]["item-name"])
    await refresh_board()

async def perform_skip(team_name: str):
    team = teams[team_name]
    if team.get("skips", 0) <= 0:
        await client.get_channel(notification_channel_id).send(
            f"Team **{team_name}** has no skips left.")
        return

    dice = GameUtils.roll_dice(3, bonus_roll=True)
    old_tile_name = tiles[team["tile"]]["item-name"]

    await advance_team(team, dice)
    GameUtils.update_last_roll(team, dice)
    team["skips"] -= 1

    announce(team_name, "skipped", old_tile_name, dice, tiles[team["tile"]]["item-name"])
    await refresh_board()

async def process_drop_approval(team_name: str):
    team = teams[team_name]
    dice = GameUtils.roll_dice(3, bonus_roll=True)
    old_tile_name = tiles[team["tile"]]["item-name"]

    await advance_team(team, dice)
    GameUtils.update_last_roll(team, dice)
    announce(team_name, "approved", old_tile_name, dice, tiles[team["tile"]]["item-name"])
    await refresh_board()

# --------------------------------------------------------------------------- #
# Event handlers
# --------------------------------------------------------------------------- #
@client.event
async def on_ready():
    await client.get_channel(notification_channel_id).purge(check=is_me)
    await refresh_board()
    print(f"[READY] {client.user} online ✔")

@client.event
async def on_message(message: discord.Message):
    if is_me(message):
        return

    tname = GameUtils.find_team_name(message.author, teams)
    content = message.content.strip().lower()

    if message.channel.id == image_channel_id and message.attachments:
        if tname:
            await client.get_channel(notification_channel_id).send(
                f"**{tname}** uploaded a drop – waiting for approval.")
        for e in (CHECK_EMOJI, CROSS_EMOJI):
            try:
                await message.add_reaction(e)
            except Exception:
                pass
        return

    if content == "!skip" and message.channel.id == notification_channel_id and tname:
        await perform_skip(tname)
        return

    if content == "!reroll" and message.channel.id == notification_channel_id and tname:
        await perform_reroll(tname)
        return

@client.event
async def on_reaction_add(reaction: discord.Reaction, user: discord.User):
    if user.bot:
        return

    if reaction.message.channel.id == image_channel_id:
        tname = GameUtils.find_team_name(user, teams)
        if not tname:
            return

        if reaction.emoji == CHECK_EMOJI:
            await process_drop_approval(tname)
        elif reaction.emoji == CROSS_EMOJI:
            await client.get_channel(notification_channel_id).send(
                f"**{tname}** drop was declined.")

    # path selection
    for team in teams.values():
        pending = team.get("pending_paths")
        if pending and str(reaction.emoji) in pending and user.id in [int(uid) for uid in team["members"]]:
            team["tile"] = pending[str(reaction.emoji)]
            del team["pending_paths"]
            await refresh_board()
            return

# --------------------------------------------------------------------------- #
# Main
# --------------------------------------------------------------------------- #
if __name__ == "__main__":
    board_data, tiles, teams = ETL.load()
    # Ensure required counters exist on every team dict
for tdata in teams.values():
    tdata.setdefault("skips", 0)
    tdata.setdefault("rerolls", 0)
    tdata.setdefault("last_roll", 0)   # (optional safety for reroll logic)
    
    image_channel_id       = int(os.getenv("IMAGE_CHANNEL_ID"))
    notification_channel_id = int(os.getenv("NOTIFICATION_CHANNEL_ID"))
    board_channel_id        = int(os.getenv("BOARD_CHANNEL_ID"))
    
    # build graph from tile data
    GRAPH = nx.DiGraph()
    for tid, tdata in tiles.items():
        for nxt in tdata.get("next", []):
            GRAPH.add_edge(tid, nxt)
# ensure every team dict has the crucial fields
for data in teams.values():
    data.setdefault("rerolls", 0)
    data.setdefault("skips",    0)
    data.setdefault("name", "")           # if you rely on it elsewhere
    data.setdefault("last_roll", 0)       # keeps perform_reroll safe

    token = os.getenv("DISCORD_TOKEN")
    if not token:
        raise RuntimeError("DISCORD_TOKEN not set in environment")
    client.run(token)
